#include <iostream>
#include <queue>
#include <stack>
using namespace std;

struct Node
{
    int item;
    Node* left;
    Node* right;

    Node(int key){
        item = key;
        left = nullptr;
        right = nullptr;
    }
};

struct Tree
{
    Node* root = nullptr;
    int search(int inL, int inR, int* in, queue<int>& q);
    queue<int> createQueue(int inL, int inR, int* in, int* level, int n);
    Node* build(int inL, int inR, int* in, int* level, int n);
    void printPre(Node* p);
    void del(Node* p);
};

queue<int> Tree :: createQueue(int inL, int inR, int* in, int* level, int n)
{
    // create subTree queue
    queue<int> q;
    for(int i=0; i<n; i++){
        for(int j=inL; j<=inR; j++){
            if(in[j] == level[i]){
                q.push(in[j]);
                break;
            }
        }
    }
    return q;
}

int Tree :: search(int inL, int inR, int* in, queue<int>& q)
{
    // find the root of subTree
    int i=inL;
    for(; i<=inR; i++){
        if(in[i] == q.front()) return i;
    }
    return -1;
}

Node* Tree :: build(int inL, int inR, int* in, int* level, int n)
{
    if(inL > inR) return nullptr;

    queue<int> q = createQueue(inL, inR, in, level, n);
    int indexK = search(inL, inR, in, q);
    Node* node = new Node(in[indexK]);

    node->left = build(inL, indexK-1, in, level, n);
    node->right = build(indexK+1, inR, in, level, n);

    return node;
}

void Tree :: printPre(Node* p)
{
    stack<Node*> s;
    while(p || !s.empty()){
        while(p){
            cout << p->item << ' ';
            s.push(p);
            p = p->left;
        }
        p = s.top();
        s.pop();
        p = p->right;
    }
}

void Tree :: del(Node* p)
{
    stack<Node*> s;
    while(p || !s.empty()){
        while(p){
            Node* cur = p;
            s.push(p);
            p = p->left;
            delete cur;
        }
        p = s.top();
        s.pop();
        p = p->right;
    }
}

int main()
{
    Tree binTree;
    int inOrder[] = {4, 8, 10, 12, 14, 20, 22};
    int levelOrder[] = {20, 8, 22, 4, 12, 10, 14};
    int n = sizeof(inOrder)/sizeof(inOrder[0]);
    int inL = 0;
    int inR = n - 1;
    binTree.root = binTree.build(inL, inR, inOrder, levelOrder, n);

    binTree.printPre(binTree.root);
    binTree.del(binTree.root);

    return 0;
}

//               20
//              /  \
//             8   22
//            / \
//           4  12
//             /  \
//            10  14
